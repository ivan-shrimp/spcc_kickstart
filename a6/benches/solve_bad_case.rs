#![feature(bench_black_box)]
use std::hint::black_box;

use criterion::{criterion_group, criterion_main, Criterion};

fn solve_bad_case(c: &mut Criterion) {
    // See below for how the bad case is generated.
    let bad = generate_bad_case(false);
    assert_eq!(a6::solve(&bad), None);

    c.bench_function("solve_bad_case", |b| b.iter(|| black_box(a6::solve(&bad))));
}

fn solve_bad_case_with_magic(c: &mut Criterion) {
    let bad = generate_bad_case(true);
    assert_eq!(a6::solve(&bad), Some(MAGIC_NUMBER));

    c.bench_function("solve_bad_case_with_magic", |b| {
        b.iter(|| black_box(a6::solve(&bad)));
    });
}

criterion_group!(benches, solve_bad_case, solve_bad_case_with_magic);
criterion_main!(benches);

// (To understand the notations below, read src/lib.rs.)
//
// Instead, a really bad case is when every input has exactly 2 prime factors
// (repeated prime factors are counted as multiple prime factors),
// because every two of them, when multiplied, yields a product with  2 + 2 = 4 prime factors.
// This would force the function to search through every single test case desperately just to return None.
// To increase the input size, we can further include numbers with 3, 7, 8, 12, 13, 17 or 18 prime factors.
// As the smallest input generated by the method above is 4,
// we can further include all the prime numbers above 1_000_000 / 4 = 250_000.
//
// Side note: The largest set of numbers from 2 to 1_000_000 that does not contain a valid `c`
// is likely to be the set of all numbers from 1001 to 1_000_000.
// However, in our `solve` function, numbers larger than sqrt(max) are not candidates of `a`!
// So if we plug these numbers into the function, it will return None really quickly.

const BAD_NUMBER_OF_PRIME_FACTORS: [u32; 8] = [2, 3, 7, 8, 12, 13, 17, 18];
const BAD_NUMBER_OF_PRIME_FACTORS_WITH_PRIMES: [u32; 9] = [1, 2, 3, 7, 8, 12, 13, 17, 18];

// This number has exactly four factors, so when it is added to the bad case,
// it will become a valid `c`. However, the corresponding `a` is at least 23 * 29 = 667.
// Because we search for `a` starting from the smallest numbers (4, 6, 8, 9, ...),
// the program will take quite some time to find this magic number as a possible `c`.
//
// The value of this magic number is 765_049.
const MAGIC_NUMBER: u32 = 23 * 29 * 31 * 37;

/// Generates a bad case, sorted.
fn generate_bad_case(include_magic_number: bool) -> Vec<u32> {
    // A sieve to 1000 can factorize numbers up to 1000^2.
    let sieve = primal::Sieve::new(1000);

    // Count the number of (potentially repeated) prime factors of this number.
    // e.g.: count_factors(6) = 2, count_factors(9) = 2
    #[allow(clippy::cast_possible_truncation)]
    let prime_factors = |num: u32| {
        sieve
            // Factorize the number.
            // Does not truncate as we're not running on 16-bit targets. We don't.
            .factor(num as usize)
            .unwrap()
            .into_iter()
            // Does not truncate because a number can't have more prime factors than itself.
            .map(|(_, count)| count as u32)
            .sum()
    };

    // Bad numbers up to 250_000.
    let low = (2..=250_000).filter(|&x| BAD_NUMBER_OF_PRIME_FACTORS.contains(&prime_factors(x)));

    if include_magic_number {
        // Bad numbers from 250_001 to the magic number.
        let mid = (250_001..MAGIC_NUMBER)
            .filter(|&x| BAD_NUMBER_OF_PRIME_FACTORS_WITH_PRIMES.contains(&prime_factors(x)));

        // The magic number itself.
        let magic = std::iter::once(MAGIC_NUMBER);

        // Bad numbers after the magic number.
        let high = (MAGIC_NUMBER + 1..=1_000_000)
            .filter(|&x| BAD_NUMBER_OF_PRIME_FACTORS_WITH_PRIMES.contains(&prime_factors(x)));

        // Return all these bad numbers.
        low.chain(mid).chain(magic).chain(high).collect()
    } else {
        // Bad numbers starting from 250_001.
        let high = (250_001..=1_000_000)
            .filter(|&x| BAD_NUMBER_OF_PRIME_FACTORS_WITH_PRIMES.contains(&prime_factors(x)));

        // Return all these bad numbers.
        low.chain(high).collect()
    }
}
